"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = require("react");
const redux_saga_1 = require("redux-saga");
const effects_1 = require("redux-saga/effects");
function* selectAsyncSaga(selector, args) {
    const { state } = yield effects_1.take("REACT_STATE_READY");
    return selector(state, ...args);
}
function useReducerAndSaga(reducer, state0, saga, sagaOptions) {
    const [state, reactDispatch] = react_1.useReducer(reducer, state0);
    const sagaEnv = react_1.useRef({ state: state0, pendingActions: [], channel: void 0 });
    function dispatch(action) {
        console.log("[useReducerAndSaga] react dispatch", action);
        reactDispatch(action);
        console.log("[useReducerAndSaga] post react dispatch", action);
        // dispatch to sagas is done in the commit phase
        sagaEnv.current.pendingActions.push(action);
    }
    react_1.useEffect(() => {
        console.log("[useReducerAndSaga] update saga state");
        // sync with react state, *should* be safe since we're in commit phase
        sagaEnv.current.state = state;
        const pendingActions = sagaEnv.current.pendingActions;
        // flush any pending actions, since we're in commit phase, reducer
        // should've handled all those actions
        if (pendingActions.length > 0) {
            sagaEnv.current.pendingActions = [];
            console.log("[useReducerAndSaga] flush saga actions");
            pendingActions.forEach(action => sagaEnv.current.channel.put(action));
            sagaEnv.current.channel.put({ type: "REACT_STATE_READY", state });
        }
    });
    // This is a one-time effect that starts the root saga
    react_1.useEffect(() => {
        sagaEnv.current.channel = redux_saga_1.stdChannel();
        const task = redux_saga_1.runSaga(Object.assign({}, sagaOptions, { channel: sagaEnv.current.channel, dispatch, getState: () => {
                /* overrided by effectMiddlewares below */
            }, effectMiddlewares: [
                runEffect => {
                    return effect => {
                        if (effect.type === effects_1.effectTypes.SELECT) {
                            return runEffect(effects_1.call(selectAsyncSaga, effect.payload.selector, effect.payload.args));
                        }
                        return runEffect(effect);
                    };
                }
            ] }), saga);
        return () => task.cancel();
    }, []);
    return [state, dispatch];
}
exports.useReducerAndSaga = useReducerAndSaga;
//# sourceMappingURL=useReducerAndSaga.js.map