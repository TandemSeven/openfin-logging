"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = require("react");
const redux_saga_1 = require("redux-saga");
const effects_1 = require("redux-saga/effects");
const redux_openfin_1 = require("redux-openfin");
const channel_1 = require("redux-openfin/channel");
const init_1 = require("../init");
const makeType_1 = require("./makeType");
const REACT_STATE_READY = 'REACT_STATE_READY';
function compose(...fns) {
    if (fns.length === 0)
        return arg => arg;
    if (fns.length === 1)
        return fns[0];
    return fns.reduce((a, b) => (...args) => a(b(...args)));
}
function* selectAsyncSaga(selector, args) {
    const { state } = yield effects_1.take(REACT_STATE_READY);
    return selector(state, ...args);
}
function useEnhancedReducerAndSaga(reducer, state0, middlewares = [], saga, sagaOptions) {
    const [state, reactDispatch] = react_1.useReducer(reducer, state0);
    const sagaEnv = react_1.useRef({ state: state0, pendingActions: [], channel: void 0 });
    function dispatch(action) {
        // console.log("[EnhancedReducerAndSaga] react dispatch", action);
        reactDispatch(action);
        // dispatch to client store if necessary
        if (init_1.default.clientReduxDispatch &&
            (redux_openfin_1.isResAct(action.type) ||
                makeType_1.isResAct(action.type) ||
                (action[channel_1.SHARED_ACTION_ORIGIN_TAG]
                    && action[channel_1.SHARED_ACTION_ORIGIN_TAG] !== window[channel_1.SHARED_ACTION_ORIGIN_TAG]
                // do not need to check sharedActionsDict since already has SHARED_ACTION_ORIGIN_TAG field
                // && initState.sharedActionsDict.has(action.type)
                ))) {
            init_1.default.clientReduxDispatch(action);
        }
        console.log("[EnhancedReducerAndSaga] post react dispatch", action);
        // dispatch to sagas is done in the commit phase
        sagaEnv.current.pendingActions.push(action);
    }
    let enhancedDispatch;
    const store = {
        getState: () => state,
        dispatch: (...args) => enhancedDispatch(...args)
    };
    const chain = middlewares.map(middleware => middleware(store));
    enhancedDispatch = compose.apply(void 0, chain)(dispatch);
    // This is a one-time effect that starts the root saga
    react_1.useEffect(() => {
        // console.log("[EnhancedReducerAndSaga] init saga stdChannel");
        sagaEnv.current.channel = redux_saga_1.stdChannel();
        const task = redux_saga_1.runSaga(Object.assign({}, sagaOptions, { channel: sagaEnv.current.channel, dispatch: enhancedDispatch, getState: () => {
                /* overrided by effectMiddlewares below */
            }, effectMiddlewares: [
                runEffect => {
                    return effect => {
                        if (effect.type === effects_1.effectTypes.SELECT) {
                            return runEffect(effects_1.call(selectAsyncSaga, effect.payload.selector, effect.payload.args));
                        }
                        return runEffect(effect);
                    };
                }
            ] }), saga);
        return () => task.cancel();
    }, []);
    react_1.useEffect(() => {
        // console.log("[EnhancedReducerAndSaga] update saga state");
        // sync with react state, *should* be safe since we're in commit phase
        sagaEnv.current.state = state;
        const pendingActions = sagaEnv.current.pendingActions;
        // flush any pending actions, since we're in commit phase, reducer
        // should've handled all those actions
        if (pendingActions.length > 0) {
            sagaEnv.current.pendingActions = [];
            // console.log("[EnhancedReducerAndSaga] flush saga actions");
            pendingActions.forEach(action => sagaEnv.current.channel.put(action));
            sagaEnv.current.channel.put({ type: REACT_STATE_READY, state });
        }
    });
    return [state, enhancedDispatch];
}
exports.useEnhancedReducerAndSaga = useEnhancedReducerAndSaga;
//# sourceMappingURL=useEnhancedReducerAndSaga.js.map