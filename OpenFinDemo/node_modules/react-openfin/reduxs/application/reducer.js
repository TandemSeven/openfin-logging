"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const redux_actions_1 = require("redux-actions");
const redux_openfin_1 = require("redux-openfin");
const init_1 = require("../../init");
const actions_1 = require("./actions");
exports.defaultState = {
    offline: false,
    username: '',
    computerName: '',
    machineId: null,
    deviceUserId: null,
    loading: true,
    loadingMsg: "",
    docked: false,
    winTop: 0,
    winLeft: 0,
    winWidth: 0,
    winHeight: 0,
    drawerOpen: true,
    launchBarCollapse: false,
    snackBarOpen: false,
    snackBarMsgInfo: {},
    snackBarMsgQueue: [],
    openfinVersion: 'n/a',
    openfinHostSpec: {},
    windowsState: 'normal',
};
exports.buildInitState = (parentWindowState) => {
    if (parentWindowState) {
        return Object.assign({}, parentWindowState, { loadingMsg: "", docked: false, winTop: 0, winLeft: 0, winWidth: 0, winHeight: 0, snackBarOpen: false, snackBarMsgInfo: {}, snackBarMsgQueue: [], openfinHostSpec: Object.assign({}, parentWindowState.openfinHostSpec), windowsState: 'normal' });
    }
    else {
        return Object.assign({}, exports.defaultState, { drawerOpen: init_1.default.config.defaultDashboardDrawerShown });
    }
};
exports.reducerMap = {
    [redux_openfin_1.System.actions.GET_MACHINE_ID_RES]: (state, action) => {
        const { id } = action.payload;
        return Object.assign({}, state, { machineId: id });
    },
    [redux_openfin_1.System.actions.GET_DEVICE_USER_ID_RES]: (state, action) => {
        const { id } = action.payload;
        return Object.assign({}, state, { deviceUserId: id });
    },
    [redux_openfin_1.System.actions.GET_ENVIRONMENT_VARIABLE_RES]: (state, action) => {
        const { env, value } = action.payload;
        if (env.toLowerCase() === 'username') {
            return Object.assign({}, state, { username: value });
        }
        else if ((env.toLowerCase() === 'computername' || env.toLowerCase() === 'hostname') && value) {
            return Object.assign({}, state, { computerName: value });
        }
        else {
            return state;
        }
    },
    [redux_openfin_1.System.actions.GET_VERSION_RES]: (state, action) => {
        const { version } = action.payload;
        return Object.assign({}, state, { openfinVersion: version });
    },
    [redux_openfin_1.System.actions.GET_HOST_SPECS_RES]: (state, action) => {
        const openfinHostSpec = action.payload;
        return Object.assign({}, state, { openfinHostSpec });
    },
    [redux_openfin_1.Window.actions.GET_STATE_RES]: (state, action) => {
        const payload = action.payload;
        return Object.assign({}, state, { windowsState: payload.state });
    },
    [redux_openfin_1.Window.actions.GET_BOUNDS_RES]: (state, action) => {
        const payload = action.payload;
        return Object.assign({}, state, { winTop: payload.top, winLeft: payload.left, winWidth: payload.width, winHeight: payload.height });
    },
    [redux_openfin_1.Event.actionDicts.windowEventDictByName['bounds-changing'].type]: (state, action) => {
        const payload = action.payload;
        return Object.assign({}, state, { winTop: payload.top, winLeft: payload.left, winWidth: payload.width, winHeight: payload.height });
    },
    [redux_openfin_1.Event.actionDicts.windowEventDictByName['group-changed'].type]: (state, action) => {
        const { sourceWindowName, targetWindowName, memeberOf, reason } = action.payload;
        if (reason === redux_openfin_1.Docking.types.GroupEventReason.JOIN && sourceWindowName === window.name) {
            return Object.assign({}, state, { docked: true });
        }
        else if ((reason === redux_openfin_1.Docking.types.GroupEventReason.LEAVE ||
            reason === redux_openfin_1.Docking.types.GroupEventReason.DISBAND)
            && sourceWindowName === window.name) {
            return Object.assign({}, state, { docked: false });
        }
        return state;
    },
    [actions_1.APPLICATION_UPDATE_DOCK_STATUS]: (state, action) => (Object.assign({}, state, { docked: action.payload.docked })),
    [actions_1.APPLICATION_SET_LOADING_MSG]: (state, action) => (Object.assign({}, state, { loadingMsg: action.payload.loadingMsg })),
    [actions_1.APPLICATION_READY]: (state, action) => (Object.assign({}, state, { loading: false })),
    [actions_1.APPLICATION_CHILD_READY]: (state, action) => (Object.assign({}, state, { loading: false })),
    [actions_1.APPLICATION_NOTIFICATION_READY]: (state, action) => (Object.assign({}, state, { loading: false })),
    [actions_1.APPLICATION_DRAWER_TOGGLE]: (state, action) => (Object.assign({}, state, { drawerOpen: !state.drawerOpen })),
    [actions_1.APPLICATION_NEW_SNACKBAR]: (state, action) => {
        const option = action.payload;
        const newMsgQueue = state.snackBarMsgQueue.concat([Object.assign({}, option, { key: new Date().getTime() })]);
        return Object.assign({}, state, { snackBarMsgQueue: newMsgQueue });
    },
    [actions_1.APPLICATION_PROCESS_SNACKBAR_QUEUE]: (state, action) => {
        if (state.snackBarMsgQueue.length > 0) {
            const newMsg = state.snackBarMsgQueue[0];
            const newMsgQueue = state.snackBarMsgQueue.slice(1);
            return Object.assign({}, state, { snackBarOpen: true, snackBarMsgInfo: newMsg, snackBarMsgQueue: newMsgQueue });
        }
        else {
            return state;
        }
    },
    [actions_1.APPLICATION_SET_SNACKBAR_STATUS]: (state, action) => {
        const { snackBarOpen } = action.payload;
        return Object.assign({}, state, { snackBarOpen });
    },
    [actions_1.APPLICATION_LAUNCH_BAR_TOGGLE_COLLAPSE]: (state, action) => (Object.assign({}, state, { launchBarCollapse: !state.launchBarCollapse })),
    [actions_1.APPLICATION_NETWORK_ONLINE]: (state, action) => (Object.assign({}, state, { offline: false })),
    [actions_1.APPLICATION_NETWORK_OFFLINE]: (state, action) => (Object.assign({}, state, { offline: true })),
};
// const reducer = (state:IApplicationState, action:Action<any>):IApplicationState => {
//     if (action.type && reducerMap[action.type]){
//         return reducerMap[action.type](state,action);
//     }else{
//         return state;
//     }
// };
exports.reducerCreator = (parentState) => {
    return redux_actions_1.handleActions(exports.reducerMap, exports.buildInitState(parentState));
};
exports.default = exports.reducerCreator;
//# sourceMappingURL=reducer.js.map