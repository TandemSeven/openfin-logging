{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst init_1 = require(\"./init\");\n\nexports.sharedActionDict = new Set();\nexports.DEFAULT_SHARED_ACTION_CHANNEL_NAME = 'ALBERTLI90_REDUX_OPENFIN_SHARED_ACTIONS';\nexports.SHARED_ACTION_ORIGIN_TAG = '_albertli90_redux_openfin_origin';\nlet channelType;\nlet channel;\nlet stackedChannel = [];\nlet channelUp = 0;\nlet dispatch; // listener is response to consume the action from channel\n\nconst sharedActionListener = type => (action, identity) => {\n  if (!('identity' in action)) {\n    action['identity'] = identity;\n  }\n\n  console.log('[redux-openfin]channel::sharedActionListener', type, action, identity);\n\n  if (channelType === init_1.ChannelType.PROVIDER) {\n    channel.publish(type, action);\n  }\n\n  if (action[exports.SHARED_ACTION_ORIGIN_TAG] !== window[exports.SHARED_ACTION_ORIGIN_TAG]) {\n    dispatch(action);\n  }\n}; // handler is response to send actions to the channel\n\n\nfunction sharedActionHandler(action) {\n  // console.log('[redux-openfin]channel::sharedActionHandler called',action,channelType,channel,stackedChannel,channelUp);\n  if (!action[exports.SHARED_ACTION_ORIGIN_TAG]) {\n    action[exports.SHARED_ACTION_ORIGIN_TAG] = window[exports.SHARED_ACTION_ORIGIN_TAG];\n    stackedChannel.push(action);\n\n    if (channelUp || channel && channelType === init_1.ChannelType.CLIENT) {\n      while (stackedChannel.length) {\n        let theAction = stackedChannel.shift();\n\n        if (channelType === init_1.ChannelType.PROVIDER) {\n          console.log('[redux-openfin]channel::sharedActionHandler PROVIDER publish');\n          channel.publish(theAction.type, theAction);\n        } else if (channelType === init_1.ChannelType.CLIENT) {\n          console.log('[redux-openfin]channel::sharedActionHandler CLIENT dispatch');\n          channel.dispatch(theAction.type, theAction).then((...args) => {\n            console.log('[redux-openfin]channel::sharedActionHandler CLIENT dispatch resolved', args);\n          }).catch(e => {\n            throw e;\n          });\n        }\n      }\n    }\n  }\n}\n\nexports.sharedActionHandler = sharedActionHandler;\n\nexports.default = (fin, config, store) => __awaiter(this, void 0, void 0, function* () {\n  if (!config.channelType) {\n    config.channelType = window.name === config.finUuid ? init_1.ChannelType.PROVIDER : init_1.ChannelType.CLIENT;\n  }\n\n  if (config.channelType != init_1.ChannelType.STANDALONE && store) {\n    const Channel = fin.InterApplicationBus.Channel;\n    let ChannelName = config.channelName ? config.channelName : config.channelRandomSuffix ? exports.DEFAULT_SHARED_ACTION_CHANNEL_NAME + '-' + new Date().getTime() : exports.DEFAULT_SHARED_ACTION_CHANNEL_NAME;\n    dispatch = store.dispatch;\n    config.sharedActions.forEach(oneAction => {\n      exports.sharedActionDict.add(oneAction);\n    });\n    window[exports.SHARED_ACTION_ORIGIN_TAG] = config.channelClientId ? config.channelClientId : window.name;\n    Channel.onChannelConnect(() => {\n      channelUp++; // console.log('[redux-openfin]channel::onChannelConnect',channelUp);\n    });\n    Channel.onChannelDisconnect(() => {\n      channelUp--; // console.log('[redux-openfin]channel::onChannelDisconnect',channelUp);\n    });\n    channelType = config.channelType;\n\n    if (config.channelType === init_1.ChannelType.PROVIDER) {\n      try {\n        channel = yield Channel.create(ChannelName);\n      } catch (e) {\n        // console.error('[redux-openfin]channel::default',e);\n        ChannelName = ChannelName + '-' + new Date().getTime();\n        channel = yield Channel.create(ChannelName);\n        console.log(\"[redux-openfin] Duplicate channel name found and use \".concat(ChannelName, \" instead\"));\n      }\n\n      init_1.initState.channel = channel;\n      window._albertli90_redux_openfin_channelname = ChannelName;\n    } else if (config.channelType === init_1.ChannelType.CLIENT) {\n      if (window.opener._albertli90_redux_openfin_channelname) {\n        channel = yield Channel.connect(window.opener._albertli90_redux_openfin_channelname, {\n          wait: true\n        });\n      } else {\n        channel = yield Channel.connect(ChannelName, {\n          wait: true\n        });\n      }\n\n      init_1.initState.channel = channel;\n    }\n\n    config.sharedActions.forEach(oneAction => {\n      channel.register(oneAction, sharedActionListener(oneAction));\n    }); // channelConfig = config;\n  }\n});","map":null,"metadata":{},"sourceType":"script"}