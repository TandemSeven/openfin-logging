{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst DockingType_1 = require(\"./DockingType\");\n\nfunction getAppId(fin) {\n  if (fin) {\n    return fin.desktop.Application.getCurrent().uuid;\n  } else {\n    return null;\n  }\n}\n\nexports.getAppId = getAppId;\n\nfunction handleMonitorInfo(openfinMonitorInfo) {\n  const allMonitors = [openfinMonitorInfo.primaryMonitor, ...openfinMonitorInfo.nonPrimaryMonitors];\n  return allMonitors.map(monitorInfo => {\n    const _monitorInfo$availabl = monitorInfo.availableRect,\n          left = _monitorInfo$availabl.left,\n          right = _monitorInfo$availabl.right,\n          top = _monitorInfo$availabl.top,\n          bottom = _monitorInfo$availabl.bottom;\n    return {\n      x: left,\n      y: top,\n      width: right - left,\n      height: bottom - top\n    };\n  });\n}\n\nfunction requestMonitorInfo(fin) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return new Promise((resolve, reject) => fin.desktop.System.getMonitorInfo(monitorData => resolve(handleMonitorInfo(monitorData)), err => reject(err)));\n  });\n}\n\nexports.requestMonitorInfo = requestMonitorInfo;\n\nfunction parsePositiveInt(option, defaultOption) {\n  return option >= 0 ? option : defaultOption;\n}\n\nexports.parsePositiveInt = parsePositiveInt;\n\nfunction parseOpacity(opacityOption, defaultOption) {\n  return opacityOption >= 0 && opacityOption <= 1 ? opacityOption : defaultOption;\n}\n\nexports.parseOpacity = parseOpacity;\n\nfunction intersect(rectangle, targetRectangle) {\n  // check right edge position of first window is to the left of left edge of second window, and so on ..\n  // comparison is <= as (xpos + width) is one pixel to the right of the window\n  return !(rectangle.x + rectangle.width <= targetRectangle.x || targetRectangle.x + targetRectangle.width <= rectangle.x || rectangle.y + rectangle.height <= targetRectangle.y || targetRectangle.y + targetRectangle.height <= rectangle.y);\n}\n\nexports.intersect = intersect;\n\nfunction isInView(rectangle, monitors) {\n  return monitors.some(monitor => intersect(rectangle, monitor) && rectangle.y >= monitor.y);\n}\n\nexports.isInView = isInView;\n\nfunction isGroupInView(rectangles, monitors) {\n  return rectangles.some(rectangle => isInView(rectangle, monitors));\n}\n\nexports.isGroupInView = isGroupInView;\n\nfunction isPointInVerticalZone(startY, endY, y, height) {\n  const bottomEdgePosition = y + height;\n  return y >= startY && y <= endY || bottomEdgePosition >= startY && bottomEdgePosition <= endY;\n}\n\nfunction isPointInHorizontalZone(startX, endX, x, width) {\n  const rightEdgePosition = x + width;\n  return x >= startX && x <= endX || rightEdgePosition >= startX && rightEdgePosition <= endX;\n}\n\nfunction getSnapDirection(currentWindow, window) {\n  const isInVerticalZone = isPointInVerticalZone(window.y, window.y + window.height, currentWindow.y, currentWindow.height);\n\n  if (isInVerticalZone && Math.abs(currentWindow.x - window.x - window.width) < currentWindow.currentRange) {\n    return DockingType_1.SnapDirection.RIGHT;\n  }\n\n  if (isInVerticalZone && Math.abs(window.x - currentWindow.x - currentWindow.width) < currentWindow.currentRange) {\n    return DockingType_1.SnapDirection.LEFT;\n  }\n\n  const isInHorizontalZone = isPointInHorizontalZone(window.x, window.x + window.width, currentWindow.x, currentWindow.width);\n\n  if (isInHorizontalZone && Math.abs(currentWindow.y - window.y - window.height) < currentWindow.currentRange) {\n    return DockingType_1.SnapDirection.BOTTOM;\n  }\n\n  if (isInHorizontalZone && Math.abs(currentWindow.y + currentWindow.height - window.y) < currentWindow.currentRange) {\n    return DockingType_1.SnapDirection.TOP;\n  }\n\n  return null;\n}\n\nexports.getSnapDirection = getSnapDirection;\n\nfunction reverseSnapDirection(direction) {\n  switch (direction) {\n    case DockingType_1.SnapDirection.RIGHT:\n      return DockingType_1.SnapDirection.LEFT;\n\n    case DockingType_1.SnapDirection.LEFT:\n      return DockingType_1.SnapDirection.RIGHT;\n\n    case DockingType_1.SnapDirection.TOP:\n      return DockingType_1.SnapDirection.BOTTOM;\n\n    case DockingType_1.SnapDirection.BOTTOM:\n      return DockingType_1.SnapDirection.TOP;\n\n    default:\n      return null;\n  }\n}\n\nexports.reverseSnapDirection = reverseSnapDirection;\n\nfunction getVerticalEdgeSnapping(window, currentWindow, range) {\n  if (Math.abs(currentWindow.y - window.y) <= range) {\n    return window.y;\n  }\n\n  if (Math.abs(currentWindow.y + currentWindow.height - window.y - window.height) <= range) {\n    return window.y + window.height - currentWindow.height;\n  }\n\n  return null;\n}\n\nfunction getHorizontalEdgeSnapping(window, currentWindow, range) {\n  if (Math.abs(currentWindow.x - window.x) <= range) {\n    return window.x;\n  }\n\n  if (Math.abs(currentWindow.x + currentWindow.width - window.x - window.width) <= range) {\n    return window.x + window.width - currentWindow.width;\n  }\n\n  return null;\n}\n\nfunction getSnappedCoordinates(newBounds, currentWindow, window, direction, range, spacing) {\n  switch (direction) {\n    case DockingType_1.SnapDirection.RIGHT:\n      return {\n        x: window.x + window.width + spacing,\n        y: getVerticalEdgeSnapping(window, newBounds, range)\n      };\n\n    case DockingType_1.SnapDirection.LEFT:\n      return {\n        x: window.x - currentWindow.width - spacing,\n        y: getVerticalEdgeSnapping(window, newBounds, range)\n      };\n\n    case DockingType_1.SnapDirection.TOP:\n      return {\n        x: getHorizontalEdgeSnapping(window, newBounds, range),\n        y: window.y - currentWindow.height - spacing\n      };\n\n    case DockingType_1.SnapDirection.BOTTOM:\n      return {\n        x: getHorizontalEdgeSnapping(window, newBounds, range),\n        y: window.y + window.height + spacing\n      };\n\n    default:\n      return null;\n  }\n}\n\nexports.getSnappedCoordinates = getSnappedCoordinates;","map":null,"metadata":{},"sourceType":"script"}