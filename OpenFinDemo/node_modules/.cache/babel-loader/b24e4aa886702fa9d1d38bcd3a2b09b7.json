{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/tandemseven/dev/openfin/OpenFinDemo/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst init_1 = require(\"../init\");\n\nconst init_2 = require(\"./init\");\n\nconst DockingType_1 = require(\"./DockingType\");\n\nconst DockingUtil_1 = require(\"./DockingUtil\");\n\nconst DockingGroup_1 = require(\"./DockingGroup\");\n\nconst openDockableWindows = {};\n\nfunction regroup(persistenceService, allWindowsToRegroup, previousWindow, currentWindow, isNewGroup) {\n  return __awaiter(this, void 0, void 0, function* () {\n    // console.warn(`Regroup ${currentWindow.name}`); // eslint-disable-line no-undef, no-console\n    const currentWindowIndex = allWindowsToRegroup.indexOf(currentWindow);\n\n    if (currentWindowIndex === -1) {\n      return; // already traversed\n    } // Important, get orig partnerships, before leave/join group destroys them below\n\n\n    const partnerWindowNames = persistenceService.retrieveRelationshipsFor(currentWindow.name); // remove this window now from pending list, we should not be visiting it again\n\n    allWindowsToRegroup.splice(currentWindowIndex, 1); // if this is a lone window, then leave group\n    // do not trigger any additional split-checking, normal checks for off-screen etc.\n\n    if (!previousWindow && partnerWindowNames.length === 0) {\n      currentWindow.leaveDockingGroup();\n      return;\n    }\n\n    if (isNewGroup) {\n      yield currentWindow.leaveDockingGroup(false);\n\n      if (previousWindow) {\n        // join previous partner window in new group\n        currentWindow.joinDockingGroup(previousWindow);\n      }\n    } // console.warn(`handlePartners for ${currentWindow.name}: ${partnerWindowNames}`); // eslint-disable-line no-undef, no-console\n\n\n    for (const partnerWindowName of partnerWindowNames) {\n      const partnerWindow = DockingWindow.getWindowByName(allWindowsToRegroup, partnerWindowName);\n\n      if (partnerWindow) {\n        // we want to serialise these operations, so await in this loop is fine\n        yield regroup(persistenceService, allWindowsToRegroup, currentWindow, partnerWindow, isNewGroup);\n      }\n    }\n  });\n}\n\nfunction checkForSplitGroup(persistenceService, dockingGroup) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (dockingGroup.children.length < 2) {\n      return;\n    } // console.warn(`checkForSplitGroup ${dockingGroup.children.length}`);\n\n\n    let existingDockingGroup = dockingGroup;\n    const windowsToRegroup = existingDockingGroup.children.concat(); // loop, until no windows left to (re)group ....\n\n    while (windowsToRegroup.length > 0) {\n      const _windowsToRegroup = _slicedToArray(windowsToRegroup, 1),\n            startWindow = _windowsToRegroup[0]; // we actively want to serialise these operations, so parallelizing is _not_ what we want\n      // eslint-disable-next-line no-await-in-loop\n\n\n      yield regroup(persistenceService, windowsToRegroup, null, startWindow, !existingDockingGroup);\n\n      if (existingDockingGroup && startWindow.group) {\n        existingDockingGroup = null;\n      }\n    }\n  });\n}\n\nclass DockingWindow {\n  constructor(finWindow, options) {\n    this.range = 40;\n    this.originalOpacity = 1;\n    this.movingOpacity = 1;\n    this.acceptDockingConnection = true;\n    this.minimized = false;\n    this.group = null; // end of Docking manager binder plz holders\n\n    this.hanldeWindowOptions = windowOptions => {\n      // make note of opacity for this existing window, set as original\n      this.originalOpacity = windowOptions && windowOptions.opacity ? windowOptions.opacity : this.originalOpacity;\n      this.handleWindowInitialized();\n    };\n\n    this.handleWindowInitialized = () => {\n      // OpenFin window close triggers a 'hidden' event, so do not tie minimize action to this event\n      this.openfinWindow.getBounds(this.completeInitialization);\n      this.openfinWindow.disableFrame();\n      this.openfinWindow.addEventListener('disabled-frame-bounds-changing', this.handleBoundsChanging);\n      this.openfinWindow.addEventListener('disabled-frame-bounds-changed', this.handleBoundsChanged);\n      this.openfinWindow.addEventListener('bounds-changed', this.handleBoundsUpdate);\n      this.openfinWindow.addEventListener('closed', this.handleClosed);\n      this.openfinWindow.addEventListener('minimized', this.handleMinimized);\n      this.openfinWindow.addEventListener('restored', this.handleRestored);\n      this.openfinWindow.addEventListener('shown', this.handleRestored);\n      this.openfinWindow.addEventListener('focused', this.handleFocused);\n      this.openfinWindow.addEventListener('group-changed', this.handleGroupChanged);\n    };\n\n    this.completeInitialization = initialWindowBounds => {\n      this.handleBoundsUpdate(initialWindowBounds);\n      openDockableWindows[this.name] = this;\n      const formerDockingPartners = init_2.initState.persistenceService.retrieveRelationshipsFor(this.name);\n\n      for (let i = 0; i < formerDockingPartners.length; i++) {\n        const potentialPartnerName = formerDockingPartners[i];\n        const potentialPartnerWindow = openDockableWindows[potentialPartnerName];\n\n        if (!potentialPartnerWindow || !DockingUtil_1.getSnapDirection(this, potentialPartnerWindow) && !DockingUtil_1.getSnapDirection(potentialPartnerWindow, this)) {\n          // garbage collection, essentially\n          // note, if a former partner has not been opened yet, then re-connecting\n          // that pair of windows will be handled by that window's persisted relationships\n          init_2.initState.persistenceService.removeRelationship(this.name, potentialPartnerName);\n        } else {\n          this.joinDockingGroup(potentialPartnerWindow);\n        }\n      }\n    };\n\n    this.handleBoundsUpdate = bounds => {\n      this.x = bounds.left;\n      this.y = bounds.top;\n      this.width = bounds.width;\n      this.height = bounds.height;\n    };\n\n    this.setOpacity = value => {\n      this.openfinWindow.updateOptions({\n        opacity: value\n      });\n    };\n\n    this.resetOpacity = () => {\n      this.openfinWindow.updateOptions({\n        opacity: this.originalOpacity\n      });\n    };\n\n    this.minimize = () => {\n      if (this.minimized) {\n        return;\n      }\n\n      this.openfinWindow.minimize();\n    };\n\n    this.restore = () => {\n      if (!this.minimized) {\n        return;\n      }\n\n      this.openfinWindow.restore();\n    };\n\n    this.handleBoundsChanging = bounds => {\n      const event = {\n        target: this,\n        preventDefault: false,\n        bounds: {\n          x: bounds.left,\n          y: bounds.top,\n          width: this.width,\n          height: this.height,\n          changedWidth: bounds.width,\n          changedHeight: bounds.height\n        }\n      };\n\n      if (this.onMove) {\n        this.onMove(event);\n      }\n\n      if (event.preventDefault) {\n        return;\n      }\n\n      if (!this.group) {\n        this.setOpacity(this.movingOpacity);\n      }\n\n      this.moveTo(bounds.left, bounds.top, bounds.width, bounds.height);\n    };\n\n    this.moveTo = (x, y, width, height) => {\n      this.x = x;\n      this.y = y;\n      this.width = width || this.width;\n      this.height = height || this.height;\n      this.openfinWindow.removeEventListener('disabled-frame-bounds-changing', this.handleBoundsChanging);\n      this.openfinWindow.setBounds(x, y, this.width, this.height, this.handleMoved);\n    };\n\n    this.handleBoundsChanged = () => {\n      this.resetOpacity();\n\n      if (this.onMoveComplete) {\n        this.onMoveComplete({\n          target: this\n        });\n      }\n    };\n\n    this.handleMoved = () => {\n      this.openfinWindow.addEventListener('disabled-frame-bounds-changing', this.handleBoundsChanging);\n    };\n\n    this.handleClosed = () => {\n      if (this.onClose) {\n        this.onClose({\n          target: this\n        });\n      }\n    };\n\n    this.handleFocused = () => {\n      if (this.onFocus) {\n        this.onFocus(this);\n      }\n    };\n\n    this.handleMinimized = () => {\n      this.minimized = true;\n\n      if (this.onMinimize) {\n        this.onMinimize(this);\n      }\n    };\n\n    this.handleRestored = () => {\n      this.minimized = false;\n\n      if (this.onRestore) {\n        this.onRestore(this);\n      }\n    };\n\n    this.handleGroupChanged = groupEvent => {\n      if (groupEvent.reason === DockingType_1.GroupEventReason.LEAVE && groupEvent.sourceWindowName === this.name && this.onLeaveGroup) {\n        this.onLeaveGroup(this.name);\n      }\n    };\n\n    this.joinDockingGroup = snappedPartnerWindow => {\n      if (!this.dockableToOthers || !snappedPartnerWindow.acceptDockingConnection) {\n        return;\n      }\n\n      if (snappedPartnerWindow.group) {\n        if (this.group) {\n          // as we do not currently allow group to group docking, short-circuit out\n          // otherwise we would need to do mergeGroup here\n          // e.g. if we inserted a window between 2 groups to 'join' them\n          return;\n        }\n\n        for (let i = 0; i < snappedPartnerWindow.group.children.length; i++) {\n          if (DockingUtil_1.intersect(this, snappedPartnerWindow.group.children[i])) {\n            return;\n          }\n        }\n      } else {\n        if (this.group) {\n          snappedPartnerWindow.joinDockingGroup(this);\n          return;\n        }\n      } // openfin operations: frame and grouping\n      // if both ungrouped, this will set up the initial group with both windows as members\n\n\n      this.openfinWindow.enableFrame();\n      snappedPartnerWindow.openfinWindow.enableFrame();\n      this.openfinWindow.joinGroup(snappedPartnerWindow.openfinWindow);\n\n      if (!this.group && !snappedPartnerWindow.group) {\n        // both ungrouped .. set partner up with new group\n        const dockingGroup = new DockingGroup_1.default();\n        dockingGroup.add(snappedPartnerWindow);\n        init_1.initState.fin.desktop.InterApplicationBus.publish('window-docked', {\n          windowName: snappedPartnerWindow.name\n        });\n      }\n\n      snappedPartnerWindow.group.add(this);\n      init_1.initState.fin.desktop.InterApplicationBus.publish('window-docked', {\n        windowName: this.name\n      });\n      init_2.initState.persistenceService.createRelationshipsBetween(this.name, snappedPartnerWindow.name);\n    };\n\n    this.leaveDockingGroup = isInitiator => __awaiter(this, void 0, void 0, function* () {\n      const group = this.group;\n\n      if (!group) {\n        return;\n      } // disconnect from docking group as soon as possible to avoid\n      // any interference in leaveGroup handling\n\n\n      group.remove(this);\n      this.openfinWindow.disableFrame(); // detach window from OpenFin runtime group\n\n      try {\n        yield new Promise((resolve, reject) => this.openfinWindow.leaveGroup(() => resolve(), err => reject(err)));\n      } catch (err) {// do not need further action here, this is likely due to a close, and window is gone\n      }\n\n      init_1.initState.fin.desktop.InterApplicationBus.publish('window-undocked', {\n        windowName: this.name\n      });\n\n      if (isInitiator) {\n        // if this window initiated the undock procedure, move apart slightly from group\n        this.openfinWindow.moveBy(this.undockOffsetX, this.undockOffsetY);\n      } else if (!DockingUtil_1.isInView(this, init_2.initState.monitors)) {\n        // if indirectly undocked e.g. last window in group\n        this.moveTo(0, 0, this.width, this.height);\n      }\n\n      if (group.children.length === 1) {\n        group.children[0].leaveDockingGroup();\n      }\n\n      if (group.children.length > 0 && !DockingUtil_1.isGroupInView(group.children, init_2.initState.monitors)) {\n        group.children[0].moveTo(0, 0);\n      }\n\n      init_2.initState.persistenceService.removeAllRelationships(this.name);\n\n      if (isInitiator) {\n        checkForSplitGroup(init_2.initState.persistenceService, group);\n      }\n    });\n\n    this.name = finWindow.name;\n    this.openfinWindow = finWindow;\n    this.openfinWindow.getOptions(this.hanldeWindowOptions, () => {\n      this.openfinWindow.addEventListener('initialized', () => {\n        this.handleWindowInitialized();\n      });\n    });\n    this.range = options.range;\n    this.spacing = options.spacing;\n    this.undockOffsetX = options.undockOffsetX;\n    this.undockOffsetY = options.undockOffsetY;\n    this.movingOpacity = options.movingOpacity;\n    this.snappedMovingOpacity = options.snappedMovingOpacity;\n    this.snappedTargetOpacity = options.snappedTargetOpacity;\n    this.dockableToOthers = options.dockableToOthers;\n    this.unregisterOnClose = options.unregisterOnClose;\n    this.currentRange = this.range;\n  }\n\n  static getWindowByName(windowList, windowName) {\n    let found = null;\n\n    if (windowList && windowName) {\n      for (let i = 0; i < windowList.length; i++) {\n        if (windowList[i].name === windowName) {\n          found = windowList[i];\n          break;\n        }\n      }\n    }\n\n    return found;\n  }\n\n}\n\nexports.default = DockingWindow;","map":null,"metadata":{},"sourceType":"script"}