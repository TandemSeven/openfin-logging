{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst handlerActions = require(\"./actions/handlerActionCreator\");\n\nconst init_1 = require(\"../init\");\n\nconst createAsyncFun_1 = require(\"../utils/createAsyncFun\");\n\nconst uuid_1 = require(\"../utils/uuid\");\n\nconst types_1 = require(\"./types\"); //http://cdn.openfin.co/jsdocs/beta/fin.desktop.Notification.html#Notification\n\n\nfunction createNotification(action) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const options = action.payload;\n    let userId = action.payload.userId;\n\n    if (!userId) {\n      userId = uuid_1.default();\n    }\n\n    let finOptions = Object.assign({}, options);\n    delete finOptions.userId;\n\n    if (init_1.initState.store) {\n      const dispatch = init_1.initState.store.dispatch;\n\n      finOptions.onClick = () => {\n        dispatch(handlerActions.notificationOnClickRes({\n          userId\n        }));\n      };\n\n      finOptions.onClose = () => {\n        dispatch(handlerActions.notificationOnCloseRes({\n          userId\n        }));\n      };\n\n      finOptions.onDismiss = () => {\n        dispatch(handlerActions.notificationOnDismissRes({\n          userId\n        }));\n      };\n\n      finOptions.onError = (reason, errorObj) => {\n        dispatch(handlerActions.notificationOnErrorRes({\n          userId,\n          reason,\n          errorObj\n        }));\n      };\n\n      finOptions.onMessage = message => {\n        dispatch(handlerActions.notificationOnMsgRes({\n          userId,\n          message\n        }));\n      };\n\n      finOptions.onShow = successObj => {\n        dispatch(handlerActions.notificationOnShowRes({\n          userId,\n          successObj\n        }));\n      };\n    }\n\n    return createAsyncFun_1.default(action, types_1.CREATE_NOTIFICATION_ERROR_MSG, handlerActions.createNotificationRes, (fin, action, resActionCreator, succCb, errCb) => {\n      let notification = new fin.desktop.Notification(finOptions, () => {\n        const responseAction = resActionCreator({\n          userId,\n          notification\n        });\n        succCb(responseAction);\n      }, errCb);\n    });\n  });\n}\n\nexports.createNotification = createNotification; //http://cdn.openfin.co/jsdocs/beta/fin.desktop.Notification.html#.getCurrent\n\nfunction getCurrent(action) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return createAsyncFun_1.default(action, types_1.NOTIFICATION_GET_CURRENT_ERROR_MSG, handlerActions.getCurrentRes, (fin, action, resActionCreator, succCb, errCb) => {\n      const notification = fin.desktop.Notification.getCurrent();\n      const responseAction = resActionCreator({\n        notification\n      });\n      succCb(responseAction);\n    });\n  });\n}\n\nexports.getCurrent = getCurrent; //http://cdn.openfin.co/jsdocs/beta/fin.desktop.Notification.html#close\n\nfunction close(action) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return createAsyncFun_1.default(action, types_1.NOTIFICATION_CLOSE_ERROR_MSG, handlerActions.closeRes, (fin, action, resActionCreator, succCb, errCb) => {\n      const notification = fin.desktop.Notification.getCurrent();\n      const responseAction = resActionCreator({});\n      notification.close(() => {\n        succCb(responseAction);\n      });\n    });\n  });\n}\n\nexports.close = close; //http://cdn.openfin.co/jsdocs/beta/fin.desktop.Notification.html#sendMessage\n\nfunction sendMessage(action) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const message = action.payload.message;\n    return createAsyncFun_1.default(action, types_1.NOTIFICATION_SEND_MSG_ERROR_MSG, handlerActions.sendMessageRes, (fin, action, resActionCreator, succCb, errCb) => {\n      const notification = fin.desktop.Notification.getCurrent();\n      const responseAction = resActionCreator({});\n      notification.sendMessage(message, () => {\n        succCb(responseAction);\n      });\n    });\n  });\n}\n\nexports.sendMessage = sendMessage; //http://cdn.openfin.co/jsdocs/beta/fin.desktop.Notification.html#sendMessageToApplication\n\nfunction sendMessageToApplication(action) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const message = action.payload.message;\n    return createAsyncFun_1.default(action, types_1.NOTIFICATION_SEND_MSG_TO_APP_ERROR_MSG, handlerActions.sendMessageToApplicationRes, (fin, action, resActionCreator, succCb, errCb) => {\n      const notification = fin.desktop.Notification.getCurrent();\n      const responseAction = resActionCreator({});\n      notification.sendMessageToApplication(message, () => {\n        succCb(responseAction);\n      });\n    });\n  });\n}\n\nexports.sendMessageToApplication = sendMessageToApplication;","map":null,"metadata":{},"sourceType":"script"}