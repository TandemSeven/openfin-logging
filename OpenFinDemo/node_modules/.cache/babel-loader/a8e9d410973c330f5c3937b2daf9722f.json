{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst redux_actions_1 = require(\"redux-actions\");\n\nconst redux_openfin_1 = require(\"redux-openfin\");\n\nconst init_1 = require(\"../../init\");\n\nconst actions_1 = require(\"./actions\");\n\nexports.defaultState = {\n  offline: false,\n  username: '',\n  computerName: '',\n  machineId: null,\n  deviceUserId: null,\n  loading: true,\n  loadingMsg: \"\",\n  docked: false,\n  winTop: 0,\n  winLeft: 0,\n  winWidth: 0,\n  winHeight: 0,\n  drawerOpen: true,\n  launchBarCollapse: false,\n  snackBarOpen: false,\n  snackBarMsgInfo: {},\n  snackBarMsgQueue: [],\n  openfinVersion: 'n/a',\n  openfinHostSpec: {},\n  windowsState: 'normal'\n};\n\nexports.buildInitState = parentWindowState => {\n  if (parentWindowState) {\n    return Object.assign({}, parentWindowState, {\n      loadingMsg: \"\",\n      docked: false,\n      winTop: 0,\n      winLeft: 0,\n      winWidth: 0,\n      winHeight: 0,\n      snackBarOpen: false,\n      snackBarMsgInfo: {},\n      snackBarMsgQueue: [],\n      openfinHostSpec: Object.assign({}, parentWindowState.openfinHostSpec),\n      windowsState: 'normal'\n    });\n  } else {\n    return Object.assign({}, exports.defaultState, {\n      drawerOpen: init_1.default.config.defaultDashboardDrawerShown\n    });\n  }\n};\n\nexports.reducerMap = {\n  [redux_openfin_1.System.actions.GET_MACHINE_ID_RES]: (state, action) => {\n    const id = action.payload.id;\n    return Object.assign({}, state, {\n      machineId: id\n    });\n  },\n  [redux_openfin_1.System.actions.GET_DEVICE_USER_ID_RES]: (state, action) => {\n    const id = action.payload.id;\n    return Object.assign({}, state, {\n      deviceUserId: id\n    });\n  },\n  [redux_openfin_1.System.actions.GET_ENVIRONMENT_VARIABLE_RES]: (state, action) => {\n    const _action$payload = action.payload,\n          env = _action$payload.env,\n          value = _action$payload.value;\n\n    if (env.toLowerCase() === 'username') {\n      return Object.assign({}, state, {\n        username: value\n      });\n    } else if ((env.toLowerCase() === 'computername' || env.toLowerCase() === 'hostname') && value) {\n      return Object.assign({}, state, {\n        computerName: value\n      });\n    } else {\n      return state;\n    }\n  },\n  [redux_openfin_1.System.actions.GET_VERSION_RES]: (state, action) => {\n    const version = action.payload.version;\n    return Object.assign({}, state, {\n      openfinVersion: version\n    });\n  },\n  [redux_openfin_1.System.actions.GET_HOST_SPECS_RES]: (state, action) => {\n    const openfinHostSpec = action.payload;\n    return Object.assign({}, state, {\n      openfinHostSpec\n    });\n  },\n  [redux_openfin_1.Window.actions.GET_STATE_RES]: (state, action) => {\n    const payload = action.payload;\n    return Object.assign({}, state, {\n      windowsState: payload.state\n    });\n  },\n  [redux_openfin_1.Window.actions.GET_BOUNDS_RES]: (state, action) => {\n    const payload = action.payload;\n    return Object.assign({}, state, {\n      winTop: payload.top,\n      winLeft: payload.left,\n      winWidth: payload.width,\n      winHeight: payload.height\n    });\n  },\n  [redux_openfin_1.Event.actionDicts.windowEventDictByName['bounds-changing'].type]: (state, action) => {\n    const payload = action.payload;\n    return Object.assign({}, state, {\n      winTop: payload.top,\n      winLeft: payload.left,\n      winWidth: payload.width,\n      winHeight: payload.height\n    });\n  },\n  [redux_openfin_1.Event.actionDicts.windowEventDictByName['group-changed'].type]: (state, action) => {\n    const _action$payload2 = action.payload,\n          sourceWindowName = _action$payload2.sourceWindowName,\n          targetWindowName = _action$payload2.targetWindowName,\n          memeberOf = _action$payload2.memeberOf,\n          reason = _action$payload2.reason;\n\n    if (reason === redux_openfin_1.Docking.types.GroupEventReason.JOIN && sourceWindowName === window.name) {\n      return Object.assign({}, state, {\n        docked: true\n      });\n    } else if ((reason === redux_openfin_1.Docking.types.GroupEventReason.LEAVE || reason === redux_openfin_1.Docking.types.GroupEventReason.DISBAND) && sourceWindowName === window.name) {\n      return Object.assign({}, state, {\n        docked: false\n      });\n    }\n\n    return state;\n  },\n  [actions_1.APPLICATION_UPDATE_DOCK_STATUS]: (state, action) => Object.assign({}, state, {\n    docked: action.payload.docked\n  }),\n  [actions_1.APPLICATION_SET_LOADING_MSG]: (state, action) => Object.assign({}, state, {\n    loadingMsg: action.payload.loadingMsg\n  }),\n  [actions_1.APPLICATION_READY]: (state, action) => Object.assign({}, state, {\n    loading: false\n  }),\n  [actions_1.APPLICATION_CHILD_READY]: (state, action) => Object.assign({}, state, {\n    loading: false\n  }),\n  [actions_1.APPLICATION_NOTIFICATION_READY]: (state, action) => Object.assign({}, state, {\n    loading: false\n  }),\n  [actions_1.APPLICATION_DRAWER_TOGGLE]: (state, action) => Object.assign({}, state, {\n    drawerOpen: !state.drawerOpen\n  }),\n  [actions_1.APPLICATION_NEW_SNACKBAR]: (state, action) => {\n    const option = action.payload;\n    const newMsgQueue = state.snackBarMsgQueue.concat([Object.assign({}, option, {\n      key: new Date().getTime()\n    })]);\n    return Object.assign({}, state, {\n      snackBarMsgQueue: newMsgQueue\n    });\n  },\n  [actions_1.APPLICATION_PROCESS_SNACKBAR_QUEUE]: (state, action) => {\n    if (state.snackBarMsgQueue.length > 0) {\n      const newMsg = state.snackBarMsgQueue[0];\n      const newMsgQueue = state.snackBarMsgQueue.slice(1);\n      return Object.assign({}, state, {\n        snackBarOpen: true,\n        snackBarMsgInfo: newMsg,\n        snackBarMsgQueue: newMsgQueue\n      });\n    } else {\n      return state;\n    }\n  },\n  [actions_1.APPLICATION_SET_SNACKBAR_STATUS]: (state, action) => {\n    const snackBarOpen = action.payload.snackBarOpen;\n    return Object.assign({}, state, {\n      snackBarOpen\n    });\n  },\n  [actions_1.APPLICATION_LAUNCH_BAR_TOGGLE_COLLAPSE]: (state, action) => Object.assign({}, state, {\n    launchBarCollapse: !state.launchBarCollapse\n  }),\n  [actions_1.APPLICATION_NETWORK_ONLINE]: (state, action) => Object.assign({}, state, {\n    offline: false\n  }),\n  [actions_1.APPLICATION_NETWORK_OFFLINE]: (state, action) => Object.assign({}, state, {\n    offline: true\n  })\n}; // const reducer = (state:IApplicationState, action:Action<any>):IApplicationState => {\n//     if (action.type && reducerMap[action.type]){\n//         return reducerMap[action.type](state,action);\n//     }else{\n//         return state;\n//     }\n// };\n\nexports.reducerCreator = parentState => {\n  return redux_actions_1.handleActions(exports.reducerMap, exports.buildInitState(parentState));\n};\n\nexports.default = exports.reducerCreator;","map":null,"metadata":{},"sourceType":"script"}