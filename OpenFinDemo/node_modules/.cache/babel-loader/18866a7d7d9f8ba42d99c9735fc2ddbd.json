{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst init_1 = require(\"../init\");\n\nconst GlobalTypes_1 = require(\"../GlobalTypes\");\n/**\n * async wrapper creator for api v1\n *\n * @deprecated\n * switch to use wrapAsyncFun instead\n *\n * @param action\n * @param ERROR_MSG\n * @param resActionCreator\n * @param finCb\n */\n\n\nfunction createAsyncFun(action, ERROR_MSG, resActionCreator, finCb) {\n  const libReduxDispatch = action[GlobalTypes_1.LIB_REDUX_DISPATCH_FIELD_NAME] && window[action[GlobalTypes_1.LIB_REDUX_DISPATCH_FIELD_NAME]] ? window[action[GlobalTypes_1.LIB_REDUX_DISPATCH_FIELD_NAME]] : void 0;\n  return new Promise((resolve, reject) => {\n    const succCb = action => {\n      if (libReduxDispatch) {\n        libReduxDispatch(action);\n      } else if (init_1.initState.store) {\n        init_1.initState.store.dispatch(action);\n      }\n\n      resolve(action);\n      ;\n    };\n\n    const errCb = e => {\n      const errMsg = e && e.message ? e.message : e ? e : ERROR_MSG;\n      const error = new Error(errMsg);\n      const rejectAction = resActionCreator({\n        name: 'Error',\n        error\n      });\n\n      if (libReduxDispatch) {\n        libReduxDispatch(action);\n      } else if (init_1.initState.store) {\n        init_1.initState.store.dispatch(rejectAction);\n      }\n\n      reject(rejectAction.error);\n    };\n\n    if (init_1.initState.fin) {\n      finCb(init_1.initState.fin, action, resActionCreator, succCb, errCb);\n    } else {\n      if (init_1.initState.store) {\n        const rejectAction = resActionCreator({\n          name: 'Error',\n          error: new Error(GlobalTypes_1.FIN_NOT_INJECTED_MSG)\n        });\n        init_1.initState.store.dispatch(rejectAction);\n        reject(rejectAction.error);\n      } else {\n        reject(new Error(GlobalTypes_1.FIN_NOT_INJECTED_MSG));\n      }\n    }\n  });\n}\n\nexports.default = createAsyncFun;","map":null,"metadata":{},"sourceType":"script"}