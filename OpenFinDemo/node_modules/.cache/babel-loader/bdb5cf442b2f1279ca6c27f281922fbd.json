{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/tandemseven/dev/openfin/OpenFinDemo/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst DockingWindow_1 = require(\"./DockingWindow\");\n\nconst init_1 = require(\"./init\");\n\nconst DockingUtil_1 = require(\"./DockingUtil\");\n\nclass DockingManager {\n  constructor(dockingOptions) {\n    this.windows = [];\n    this.snappedWindows = {};\n\n    this.register = (window, dockableToOthers) => {\n      if (this.windows.some(registeredWindow => registeredWindow.name === window.name)) {\n        return;\n      }\n\n      const dockingOptions = Object.assign({}, init_1.initState.options);\n      dockingOptions.dockableToOthers = dockableToOthers !== false;\n      const dockingWindow = new DockingWindow_1.default(window, dockingOptions);\n      dockingWindow.onMove = this.handleWindowMove;\n      dockingWindow.onMoveComplete = this.dockAllSnappedWindows;\n      dockingWindow.onFocus = this.bringWindowOrGroupToFront;\n      dockingWindow.onRestore = this.handleWindowRestore;\n      dockingWindow.onMinimize = this.handleWindowMinimize;\n      dockingWindow.onLeaveGroup = this.undockWindow;\n\n      if (init_1.initState.options.unregisterOnClose) {\n        dockingWindow.onClose = this.handleWindowClose;\n      }\n\n      this.windows.push(dockingWindow);\n    };\n\n    this.unregister = window => {\n      this.unregisterByName(window.name);\n    };\n\n    this.unregisterByName = windowName => {\n      const existingWindowIdx = this.windows.findIndex(window => window.name === windowName);\n\n      if (existingWindowIdx > -1) {\n        const _this$windows$splice = this.windows.splice(existingWindowIdx, 1),\n              _this$windows$splice2 = _slicedToArray(_this$windows$splice, 1),\n              removedDockableWindow = _this$windows$splice2[0]; // purge from DockableGroup etc., otherwise it will still influence other DockableWindows\n\n\n        removedDockableWindow.leaveDockingGroup(true);\n      }\n    };\n\n    this.undockAll = () => {\n      for (const dockingWindow of this.windows) {\n        dockingWindow.leaveDockingGroup();\n      }\n    };\n\n    this.handleWindowClose = event => {\n      this.unregister(event.target);\n    };\n\n    this.bringWindowOrGroupToFront = dockingWindow => {\n      if (dockingWindow.group) {\n        for (const groupDockingWindow of dockingWindow.group.children) {\n          groupDockingWindow.openfinWindow.bringToFront();\n        }\n      }\n\n      dockingWindow.openfinWindow.bringToFront();\n    };\n\n    this.handleWindowRestore = dockingWindow => {\n      if (!dockingWindow.group) {\n        return;\n      }\n\n      for (const groupedDockingWindow of dockingWindow.group.children) {\n        groupedDockingWindow.restore();\n      }\n    };\n\n    this.handleWindowMinimize = dockingWindow => {\n      if (!dockingWindow.group) {\n        return;\n      }\n\n      for (const groupedDockingWindow of dockingWindow.group.children) {\n        groupedDockingWindow.minimize();\n      }\n    };\n\n    this.handleWindowMove = event => {\n      const currentWindow = event.target;\n\n      if (currentWindow.group) {\n        return;\n      }\n\n      const windowInfo = Object.assign({\n        currentRange: currentWindow.currentRange\n      }, event.bounds);\n      const position = {\n        x: null,\n        y: null\n      };\n\n      for (let i = this.windows.length - 1; i >= 0; i--) {\n        const dockableWindow = this.windows[i];\n        let snapDirection = DockingUtil_1.getSnapDirection(windowInfo, dockableWindow);\n\n        if (!snapDirection) {\n          snapDirection = DockingUtil_1.reverseSnapDirection(DockingUtil_1.getSnapDirection(dockableWindow, windowInfo));\n        } // console.log(`DockingManager::handleWindowMove${event.target.name}->${dockableWindow.name}`,snapDirection);\n\n\n        if (snapDirection) {\n          currentWindow.currentRange = currentWindow.range + 10;\n          const pos = DockingUtil_1.getSnappedCoordinates(windowInfo, currentWindow, dockableWindow, snapDirection, this.range, this.spacing);\n          this.bringWindowOrGroupToFront(dockableWindow); // make sure current window remains on top / in focus\n\n          currentWindow.openfinWindow.bringToFront();\n\n          if (!position.x) {\n            position.x = pos.x;\n          }\n\n          if (!position.y) {\n            position.y = pos.y;\n          }\n\n          this.addToSnapList(currentWindow, dockableWindow);\n        } else {\n          currentWindow.currentRange = currentWindow.range;\n          this.removeFromSnapList(currentWindow, dockableWindow);\n        }\n      }\n\n      if (position.x || position.y) {\n        event.preventDefault = true;\n        position.x = position.x ? position.x : windowInfo.x;\n        position.y = position.y ? position.y : windowInfo.y;\n        currentWindow.moveTo(position.x, position.y);\n        this.checkIfStillSnapped();\n      }\n    };\n\n    this.dockAllSnappedWindows = () => {\n      for (const snappedWindowInfo of Object.values(this.snappedWindows)) {\n        this.removeFromSnapList(snappedWindowInfo[0], snappedWindowInfo[1]);\n        this.addWindowToTheGroup(snappedWindowInfo[0], snappedWindowInfo[1]);\n      }\n    };\n\n    this.undockWindow = windowName => {\n      const existingWindow = DockingWindow_1.default.getWindowByName(this.windows, windowName);\n\n      if (existingWindow) {\n        existingWindow.leaveDockingGroup(true);\n      }\n    };\n\n    this.addWindowToTheGroup = (snappedWindow, groupedWindow) => {\n      snappedWindow.resetOpacity();\n      snappedWindow.joinDockingGroup(groupedWindow);\n    };\n\n    this.checkIfStillSnapped = () => {\n      for (const snappedWindowInfo of Object.values(this.snappedWindows)) {\n        if (snappedWindowInfo && !DockingUtil_1.getSnapDirection(snappedWindowInfo[0], snappedWindowInfo[1]) && !DockingUtil_1.getSnapDirection(snappedWindowInfo[1], snappedWindowInfo[0])) {\n          this.removeFromSnapList(snappedWindowInfo[0], snappedWindowInfo[1]);\n        }\n      }\n    };\n\n    this.addToSnapList = (window1, window2) => {\n      this.snappedWindows[window1.name + window2.name] = [window1, window2];\n      window1.setOpacity(this.snappedMovingOpacity);\n      window2.setOpacity(this.snappedTargetOpacity);\n    };\n\n    this.removeFromSnapList = (window1, window2) => {\n      if (this.snappedWindows[window1.name + window2.name]) {\n        Reflect.deleteProperty(this.snappedWindows, window1.name + window2.name);\n        window2.resetOpacity();\n      }\n    };\n\n    Object.assign(this, dockingOptions);\n  }\n\n}\n\nexports.default = DockingManager;","map":null,"metadata":{},"sourceType":"script"}