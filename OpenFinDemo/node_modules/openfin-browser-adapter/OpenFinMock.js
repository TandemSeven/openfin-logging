"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var OpenFinMock = (function () {
    function OpenFinMock() {
    }
    OpenFinMock.generateMethods = function (name, Klass) {
        var staticMethods = Klass.staticMethods || [];
        var instanceMethods = Klass.instanceMethods || [];
        var _loop_1 = function (method) {
            if (Klass[method]) {
                console.warn("[OpenFinMock] Warning! Attempt to overwrite already implemented static methods:`" + name + "." + method + "`. This method will not be overwritten. Remove this method from `" + name + ".staticMethods`.");
                return "continue";
            }
            Klass[method] = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var argsMsg = '';
                if (args.length) {
                    argsMsg = "This method also received the arguments: " + JSON.stringify(args, null, 2);
                }
                if (args.length > 1 && typeof args[args.length - 2] === 'function') {
                    args[args.length - 2]();
                }
                if (!OpenFinMock.silentMode) {
                    console.info("[OpenFinMock] Static method `" + name + "." + method + "` not implemented. \n                        " + argsMsg + " This method will not return anything, which will probably have unintended consequence.\n                        Implement this method on the `" + name + "` class to return a value.               \n                    ");
                }
            };
        };
        for (var _i = 0, staticMethods_1 = staticMethods; _i < staticMethods_1.length; _i++) {
            var method = staticMethods_1[_i];
            _loop_1(method);
        }
        var _loop_2 = function (method) {
            if (Klass.prototype[method]) {
                console.warn("[OpenFinMock] Warning! Attemp to overwrite already implemented instance method: `" + name + "#" + method + "`.\n                    This method will not be overwritten. Remove this method from `" + name + ".instanceMethods`.       \n                ");
                return "continue";
            }
            Klass.prototype[method] = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var argsMsg = '';
                if (args.length) {
                    argsMsg = "This method also received the arguments: " + JSON.stringify(args, null, 2);
                }
                if (args.length > 1 && typeof args[args.length - 2] === 'function') {
                    args[args.length - 2]();
                }
                if (!OpenFinMock.silentMode) {
                    console.info("[OpenFinMock] Instance method `" + name + "." + method + "` not implemented. \n                        " + argsMsg + " This method will not return anything, which will probably have unintended consequence.\n                        Implement this method on the `" + name + "` class to return a value.               \n                    ");
                }
            };
        };
        for (var _a = 0, instanceMethods_1 = instanceMethods; _a < instanceMethods_1.length; _a++) {
            var method = instanceMethods_1[_a];
            _loop_2(method);
        }
        return Klass;
    };
    OpenFinMock.silentMode = false;
    return OpenFinMock;
}());
exports.OpenFinMock = OpenFinMock;
