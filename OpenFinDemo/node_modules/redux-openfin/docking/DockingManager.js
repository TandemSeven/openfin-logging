"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const DockingWindow_1 = require("./DockingWindow");
const init_1 = require("./init");
const DockingUtil_1 = require("./DockingUtil");
class DockingManager {
    constructor(dockingOptions) {
        this.windows = [];
        this.snappedWindows = {};
        this.register = (window, dockableToOthers) => {
            if (this.windows.some(registeredWindow => registeredWindow.name === window.name)) {
                return;
            }
            const dockingOptions = Object.assign({}, init_1.initState.options);
            dockingOptions.dockableToOthers = dockableToOthers !== false;
            const dockingWindow = new DockingWindow_1.default(window, dockingOptions);
            dockingWindow.onMove = this.handleWindowMove;
            dockingWindow.onMoveComplete = this.dockAllSnappedWindows;
            dockingWindow.onFocus = this.bringWindowOrGroupToFront;
            dockingWindow.onRestore = this.handleWindowRestore;
            dockingWindow.onMinimize = this.handleWindowMinimize;
            dockingWindow.onLeaveGroup = this.undockWindow;
            if (init_1.initState.options.unregisterOnClose) {
                dockingWindow.onClose = this.handleWindowClose;
            }
            this.windows.push(dockingWindow);
        };
        this.unregister = (window) => {
            this.unregisterByName(window.name);
        };
        this.unregisterByName = (windowName) => {
            const existingWindowIdx = this.windows.findIndex(window => window.name === windowName);
            if (existingWindowIdx > -1) {
                const [removedDockableWindow] = this.windows.splice(existingWindowIdx, 1);
                // purge from DockableGroup etc., otherwise it will still influence other DockableWindows
                removedDockableWindow.leaveDockingGroup(true);
            }
        };
        this.undockAll = () => {
            for (const dockingWindow of this.windows) {
                dockingWindow.leaveDockingGroup();
            }
        };
        this.handleWindowClose = (event) => {
            this.unregister(event.target);
        };
        this.bringWindowOrGroupToFront = (dockingWindow) => {
            if (dockingWindow.group) {
                for (const groupDockingWindow of dockingWindow.group.children) {
                    groupDockingWindow.openfinWindow.bringToFront();
                }
            }
            dockingWindow.openfinWindow.bringToFront();
        };
        this.handleWindowRestore = (dockingWindow) => {
            if (!dockingWindow.group) {
                return;
            }
            for (const groupedDockingWindow of dockingWindow.group.children) {
                groupedDockingWindow.restore();
            }
        };
        this.handleWindowMinimize = (dockingWindow) => {
            if (!dockingWindow.group) {
                return;
            }
            for (const groupedDockingWindow of dockingWindow.group.children) {
                groupedDockingWindow.minimize();
            }
        };
        this.handleWindowMove = (event) => {
            const currentWindow = event.target;
            if (currentWindow.group) {
                return;
            }
            const windowInfo = Object.assign({
                currentRange: currentWindow.currentRange
            }, event.bounds);
            const position = {
                x: null,
                y: null
            };
            for (let i = this.windows.length - 1; i >= 0; i--) {
                const dockableWindow = this.windows[i];
                let snapDirection = DockingUtil_1.getSnapDirection(windowInfo, dockableWindow);
                if (!snapDirection) {
                    snapDirection = DockingUtil_1.reverseSnapDirection(DockingUtil_1.getSnapDirection(dockableWindow, windowInfo));
                }
                // console.log(`DockingManager::handleWindowMove${event.target.name}->${dockableWindow.name}`,snapDirection);
                if (snapDirection) {
                    currentWindow.currentRange = currentWindow.range + 10;
                    const pos = DockingUtil_1.getSnappedCoordinates(windowInfo, currentWindow, dockableWindow, snapDirection, this.range, this.spacing);
                    this.bringWindowOrGroupToFront(dockableWindow);
                    // make sure current window remains on top / in focus
                    currentWindow.openfinWindow.bringToFront();
                    if (!position.x) {
                        position.x = pos.x;
                    }
                    if (!position.y) {
                        position.y = pos.y;
                    }
                    this.addToSnapList(currentWindow, dockableWindow);
                }
                else {
                    currentWindow.currentRange = currentWindow.range;
                    this.removeFromSnapList(currentWindow, dockableWindow);
                }
            }
            if (position.x || position.y) {
                event.preventDefault = true;
                position.x = position.x ? position.x : windowInfo.x;
                position.y = position.y ? position.y : windowInfo.y;
                currentWindow.moveTo(position.x, position.y);
                this.checkIfStillSnapped();
            }
        };
        this.dockAllSnappedWindows = () => {
            for (const snappedWindowInfo of Object.values(this.snappedWindows)) {
                this.removeFromSnapList(snappedWindowInfo[0], snappedWindowInfo[1]);
                this.addWindowToTheGroup(snappedWindowInfo[0], snappedWindowInfo[1]);
            }
        };
        this.undockWindow = (windowName) => {
            const existingWindow = DockingWindow_1.default.getWindowByName(this.windows, windowName);
            if (existingWindow) {
                existingWindow.leaveDockingGroup(true);
            }
        };
        this.addWindowToTheGroup = (snappedWindow, groupedWindow) => {
            snappedWindow.resetOpacity();
            snappedWindow.joinDockingGroup(groupedWindow);
        };
        this.checkIfStillSnapped = () => {
            for (const snappedWindowInfo of Object.values(this.snappedWindows)) {
                if (snappedWindowInfo &&
                    !DockingUtil_1.getSnapDirection(snappedWindowInfo[0], snappedWindowInfo[1]) &&
                    !DockingUtil_1.getSnapDirection(snappedWindowInfo[1], snappedWindowInfo[0])) {
                    this.removeFromSnapList(snappedWindowInfo[0], snappedWindowInfo[1]);
                }
            }
        };
        this.addToSnapList = (window1, window2) => {
            this.snappedWindows[window1.name + window2.name] = [
                window1,
                window2
            ];
            window1.setOpacity(this.snappedMovingOpacity);
            window2.setOpacity(this.snappedTargetOpacity);
        };
        this.removeFromSnapList = (window1, window2) => {
            if (this.snappedWindows[window1.name + window2.name]) {
                Reflect.deleteProperty(this.snappedWindows, window1.name + window2.name);
                window2.resetOpacity();
            }
        };
        Object.assign(this, dockingOptions);
    }
}
exports.default = DockingManager;
