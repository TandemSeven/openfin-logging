"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const DockingType_1 = require("./DockingType");
function getAppId(fin) {
    if (fin) {
        return fin.desktop.Application.getCurrent().uuid;
    }
    else {
        return null;
    }
}
exports.getAppId = getAppId;
function handleMonitorInfo(openfinMonitorInfo) {
    const allMonitors = [openfinMonitorInfo.primaryMonitor, ...openfinMonitorInfo.nonPrimaryMonitors];
    return allMonitors.map((monitorInfo) => {
        const { left, right, top, bottom } = monitorInfo.availableRect;
        return {
            x: left,
            y: top,
            width: right - left,
            height: bottom - top
        };
    });
}
function requestMonitorInfo(fin) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => fin.desktop.System.getMonitorInfo(monitorData => resolve(handleMonitorInfo(monitorData)), err => reject(err)));
    });
}
exports.requestMonitorInfo = requestMonitorInfo;
function parsePositiveInt(option, defaultOption) {
    return option >= 0 ? option : defaultOption;
}
exports.parsePositiveInt = parsePositiveInt;
function parseOpacity(opacityOption, defaultOption) {
    return (opacityOption >= 0
        && opacityOption <= 1) ? opacityOption : defaultOption;
}
exports.parseOpacity = parseOpacity;
function intersect(rectangle, targetRectangle) {
    // check right edge position of first window is to the left of left edge of second window, and so on ..
    // comparison is <= as (xpos + width) is one pixel to the right of the window
    return !(rectangle.x + rectangle.width <= targetRectangle.x ||
        targetRectangle.x + targetRectangle.width <= rectangle.x ||
        rectangle.y + rectangle.height <= targetRectangle.y ||
        targetRectangle.y + targetRectangle.height <= rectangle.y);
}
exports.intersect = intersect;
function isInView(rectangle, monitors) {
    return monitors.some((monitor) => intersect(rectangle, monitor) && rectangle.y >= monitor.y);
}
exports.isInView = isInView;
function isGroupInView(rectangles, monitors) {
    return rectangles.some((rectangle) => isInView(rectangle, monitors));
}
exports.isGroupInView = isGroupInView;
function isPointInVerticalZone(startY, endY, y, height) {
    const bottomEdgePosition = y + height;
    return y >= startY && y <= endY || bottomEdgePosition >= startY && bottomEdgePosition <= endY;
}
function isPointInHorizontalZone(startX, endX, x, width) {
    const rightEdgePosition = x + width;
    return x >= startX && x <= endX || rightEdgePosition >= startX && rightEdgePosition <= endX;
}
function getSnapDirection(currentWindow, window) {
    const isInVerticalZone = isPointInVerticalZone(window.y, window.y + window.height, currentWindow.y, currentWindow.height);
    if (isInVerticalZone && Math.abs(currentWindow.x - window.x - window.width) < currentWindow.currentRange) {
        return DockingType_1.SnapDirection.RIGHT;
    }
    if (isInVerticalZone && Math.abs(window.x - currentWindow.x - currentWindow.width) < currentWindow.currentRange) {
        return DockingType_1.SnapDirection.LEFT;
    }
    const isInHorizontalZone = isPointInHorizontalZone(window.x, window.x + window.width, currentWindow.x, currentWindow.width);
    if (isInHorizontalZone && Math.abs(currentWindow.y - window.y - window.height) < currentWindow.currentRange) {
        return DockingType_1.SnapDirection.BOTTOM;
    }
    if (isInHorizontalZone && Math.abs(currentWindow.y + currentWindow.height - window.y) < currentWindow.currentRange) {
        return DockingType_1.SnapDirection.TOP;
    }
    return null;
}
exports.getSnapDirection = getSnapDirection;
function reverseSnapDirection(direction) {
    switch (direction) {
        case DockingType_1.SnapDirection.RIGHT:
            return DockingType_1.SnapDirection.LEFT;
        case DockingType_1.SnapDirection.LEFT:
            return DockingType_1.SnapDirection.RIGHT;
        case DockingType_1.SnapDirection.TOP:
            return DockingType_1.SnapDirection.BOTTOM;
        case DockingType_1.SnapDirection.BOTTOM:
            return DockingType_1.SnapDirection.TOP;
        default:
            return null;
    }
}
exports.reverseSnapDirection = reverseSnapDirection;
function getVerticalEdgeSnapping(window, currentWindow, range) {
    if (Math.abs(currentWindow.y - window.y) <= range) {
        return window.y;
    }
    if (Math.abs(currentWindow.y + currentWindow.height - window.y - window.height) <= range) {
        return window.y + window.height - currentWindow.height;
    }
    return null;
}
function getHorizontalEdgeSnapping(window, currentWindow, range) {
    if (Math.abs(currentWindow.x - window.x) <= range) {
        return window.x;
    }
    if (Math.abs(currentWindow.x + currentWindow.width - window.x - window.width) <= range) {
        return window.x + window.width - currentWindow.width;
    }
    return null;
}
function getSnappedCoordinates(newBounds, currentWindow, window, direction, range, spacing) {
    switch (direction) {
        case DockingType_1.SnapDirection.RIGHT:
            return {
                x: window.x + window.width + spacing,
                y: getVerticalEdgeSnapping(window, newBounds, range)
            };
        case DockingType_1.SnapDirection.LEFT:
            return {
                x: window.x - currentWindow.width - spacing,
                y: getVerticalEdgeSnapping(window, newBounds, range)
            };
        case DockingType_1.SnapDirection.TOP:
            return {
                x: getHorizontalEdgeSnapping(window, newBounds, range),
                y: window.y - currentWindow.height - spacing
            };
        case DockingType_1.SnapDirection.BOTTOM:
            return {
                x: getHorizontalEdgeSnapping(window, newBounds, range),
                y: window.y + window.height + spacing
            };
        default:
            return null;
    }
}
exports.getSnappedCoordinates = getSnappedCoordinates;
