"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const init_1 = require("../init");
const GlobalTypes_1 = require("../GlobalTypes");
/**
 * async wrapper creator for api v1
 *
 * @deprecated
 * switch to use wrapAsyncFun instead
 *
 * @param action
 * @param ERROR_MSG
 * @param resActionCreator
 * @param finCb
 */
function createAsyncFun(action, ERROR_MSG, resActionCreator, finCb) {
    const libReduxDispatch = (action[GlobalTypes_1.LIB_REDUX_DISPATCH_FIELD_NAME] && window[action[GlobalTypes_1.LIB_REDUX_DISPATCH_FIELD_NAME]]) ?
        window[action[GlobalTypes_1.LIB_REDUX_DISPATCH_FIELD_NAME]] :
        void 0;
    return new Promise((resolve, reject) => {
        const succCb = (action) => {
            if (libReduxDispatch) {
                libReduxDispatch(action);
            }
            else if (init_1.initState.store) {
                init_1.initState.store.dispatch(action);
            }
            resolve(action);
            ;
        };
        const errCb = (e) => {
            const errMsg = e && e.message
                ? e.message
                : e ? e : ERROR_MSG;
            const error = new Error(errMsg);
            const rejectAction = resActionCreator({
                name: 'Error',
                error
            });
            if (libReduxDispatch) {
                libReduxDispatch(action);
            }
            else if (init_1.initState.store) {
                init_1.initState.store.dispatch(rejectAction);
            }
            reject(rejectAction.error);
        };
        if (init_1.initState.fin) {
            finCb(init_1.initState.fin, action, resActionCreator, succCb, errCb);
        }
        else {
            if (init_1.initState.store) {
                const rejectAction = resActionCreator({
                    name: 'Error',
                    error: new Error(GlobalTypes_1.FIN_NOT_INJECTED_MSG),
                });
                init_1.initState.store.dispatch(rejectAction);
                reject(rejectAction.error);
            }
            else {
                reject(new Error(GlobalTypes_1.FIN_NOT_INJECTED_MSG));
            }
        }
    });
}
exports.default = createAsyncFun;
